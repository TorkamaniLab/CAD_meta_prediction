import xgboost as xgb
from catboost import CatBoostClassifier, CatBoostRegressor
import lightgbm as lgb
from sklearn.ensemble import RandomForestClassifier, RandomForestRegressor
from sklearn.linear_model import LogisticRegression, LinearRegression


global classifiers, regressors, estimators_dict, params_dict

classifiers = [("xgb", "classifier"), ("lgb", "classifier"), ("cat", "classifier"), ("rf", "classifier"), ("lm", "classifier")]
regressors = [("xgb", "regressor"), ("lgb", "regressor"), ("cat", "regressor"), ("rf", "regressor"), ("lm", "regressor")]

global estimators_dict
estimators_dict = {
    # classifer
    ("xgb", "classifier"): xgb.XGBClassifier(),
    ("lgb", "classifier"): lgb.LGBMClassifier(),
    ("cat", "classifier"): CatBoostClassifier(), 
    ("rf", "classifier"): RandomForestClassifier(),
    ("lm", "classifier"): LogisticRegression(),
    
    #regressor
    ("xgb", "regressor"): xgb.XGBRegressor(),
    ("lgb", "regressor"): lgb.LGBMRegressor(),
    ("cat", "regressor"): CatBoostRegressor(),
    ("rf", "regressor"): RandomForestRegressor(),
    ("lm", "regressor"): LinearRegression(),
}
 
global params_dict
params_dict = {
    
    ("xgb", "classifier"): {
            "objective": ["binary:logistic"],
            # "base_score": [None],
            # "booster": [None],  # TODO: new booster
            # "colsample_bylevel": [None],
            # "colsample_bynode": [None],
            # "colsample_bytree": [0.5, 1],
            # "enable_categorical": [True],
            "eval_metric": ["auc"],
            "gamma": [1e-8, 10],
            # "grow_policy": [None],
            "learning_rate": [0.001, 0.3],
            "max_bin": [2, 20],
            # "max_delta_step": [None],
            "max_depth": [4, 50], # 100], # 50], # 200],  
            # "max_leaves": [None],
            "min_child_weight": [0, 15],
            # https://machinelearningmastery.com/tune-number-size-decision-trees-xgboost-python/
            # https://stackoverflow.com/questions/65983344/how-to-choose-the-values-of-n-estimators-and-seed-in-xgbregressor
            "n_estimators": [50, 500], # 2000],
            "n_jobs": [-1, -1],
            # "num_parallel_tree": [None],
            # "predictor": [None],
            "random_state": [19920722, 19920722],
            "reg_alpha": [0, 10],
            "reg_lambda": [0, 10],
            # "sampling_method": [None],
            "scale_pos_weight": [0.5, 20],  ## 95 / 5 = 19,   0.04 5/95= 0.05 0.6
            # "subsample": [0.5, 1.0],
            # "tree_method": [None],
            # "validate_parameters": [None],
            # "verbosity": [None]
        }, 
    
    ("lgb", "classifier"): {
            "boosting_type": ["gbdt"],
            "num_leaves": [10, 100], # 31
            # "max_depth": -1,
            "learning_rate": [0.001, 0.3],
            "n_estimators": [50, 500], #2000],
            # "subsample_for_bin": 200000,
            # "objective": None,
            # "class_weight": None,
            # "min_split_gain": 0.0,
            # "min_child_weight": 0.001,
            # "min_child_samples": 20,
            # "subsample": [1.0],
            # "subsample_freq": [0],
            # "colsample_bytree": [0.5, 1],
            "reg_alpha": [0, 10],
            "reg_lambda": [0, 10],
            "random_state": [19920722, 19920722],
            "n_jobs": [-1, -1],
            # "silent": "warn",
            # "importance_type": ["split"],
        },
    
    ("cat", "classifier"): {
            # "nan_mode": ["Min"],
            "eval_metric": ["Logloss"],
            # "iterations": [50,200],
            # "sampling_frequency": "PerTree",
            # "leaf_estimation_method": "Newton",
            # "grow_policy": "SymmetricTree",
            # "penalties_coefficient": 1,
            # "boosting_type": "Plain",
            # "model_shrink_mode": "Constant",
            # "feature_border_type": "GreedyLogSum",
            # "bayesian_matrix_reg": 0.10000000149011612,
            # "force_unit_auto_pair_weights": False,
            # "l2_leaf_reg": 3,
            # "random_strength": 1,
            # "rsm": 1,
            # "boost_from_average": False,
            # "model_size_reg": 0.5,
            # "pool_metainfo_options": {"tags": {}},
            # "subsample": 1,
            # "use_best_model": False,
            # "class_names": [0, 1],
            "random_seed": [19920722, 19920722],
            "depth": [4, 10],
            # "posterior_sampling": False,
            # "border_count": 254,
            # "classes_count": 0,
            # "auto_class_weights": "None",
            # "sparse_features_conflict_fraction": 0,
            # "leaf_estimation_backtracking": "AnyImprovement",
            # "best_model_min_trees": 1,
            # "model_shrink_rate": 0,
            # "min_data_in_leaf": 1,
            "loss_function": ["Logloss"],
            "learning_rate": [0.001, 0.3],
            # "score_function": "Cosine",
            # "task_type": "CPU",
            # "leaf_estimation_iterations": 10,
            # "bootstrap_type": "MVS",
            # "max_leaves": 64,
            # "scale_pos_weight": None,
            # "class_weights": None,
            # "eta": None,
            # "n_estimators": None,
            'verbose': [False, False],
        },
    
    
    ("rf", "classifier"): {
            "n_estimators": [50, 500],
            "criterion": ["gini"],
            # "max_depth": None,
            "min_samples_split": [2, 20],
            "min_samples_leaf": [1, 20],
            # "min_weight_fraction_leaf": 0.0,
            # "max_features": "sqrt",
            # "max_leaf_nodes": None,
            # "min_impurity_decrease": 0.0,
            # "bootstrap": True,
            # "oob_score": False,
            "n_jobs": [-1, -1],
            "random_state": [19920722, 19920722],
            # "verbose": 0,
            # "warm_start": False,
            # "class_weight": None,
            # "ccp_alpha": 0.0,
            # "max_samples": None,
        },

    ("lm", "classifier"): {
            # "penalty": ["l2"],
            # "dual": False,
            # "tol": 1e-4,
            "C": [0.0, 1.0],
            # "fit_intercept": True,
            # "intercept_scaling": 1,
            # "class_weight": {0:0.5, 1:1000000000},
            "random_state": [19920722, 19920722],
            "solver": ["liblinear", "newton-cg", "lbfgs","sag","saga"],
            "max_iter": [200],
            # "multi_class": "auto",
            # "verbose": [0],
            # "warm_start": False,
            "n_jobs": [-1, -1],
            # "l1_ratio": None,
        }, 
    
    ("xgb", "regressor"): {
            "objective": ["reg:squarederror"],
            # "base_score": [None],
            # "booster": [None],  # TODO: new booster
            # "colsample_bylevel": [None],
            # "colsample_bynode": [None],
            # "colsample_bytree": [0.5, 1],
            # "enable_categorical": [True],
            # "eval_metric": None,
            "gamma": [1e-8, 10],
            # "grow_policy": [None],
            "learning_rate": [0.001, 0.3],
            "max_bin": [2, 20],
            # "max_delta_step": [None],
            "max_depth": [4, 50], # 100],   
            # "max_leaves": [None],
            "min_child_weight": [0, 15],
            "n_estimators": [50, 500], # 2000],
            "n_jobs": [-1, -1],
            # "num_parallel_tree": [None],
            # "predictor": [None],
            "random_state": [19920722, 19920722],
            "reg_alpha": [0, 10],
            "reg_lambda": [0, 10],
            # "sampling_method": [None],
            "scale_pos_weight": [0.5, 20],  ## 95 / 5 = 19,   0.04 5/95= 0.05 0.6
            # "subsample": [0.5, 1.0],
            # "tree_method": [None],
            # "validate_parameters": [None],
            # "verbosity": [None]
        }, 
    
    ("lgb", "regressor"): {
            "boosting_type": ["gbdt"],
            "num_leaves": [10, 500], # 31
            # "max_depth": -1,
            "learning_rate": [0.001, 0.3],
            "n_estimators": [50, 500], # 2000],
            # "subsample_for_bin": 200000,
            # "objective": None,
            # "min_split_gain": 0.0,
            # "min_child_weight": 0.001,
            # "min_child_samples": 20,
            # "subsample": [1.0],
            # "subsample_freq": [0],
            # "colsample_bytree": [0.5, 1],
            "reg_alpha": [0, 10],
            "reg_lambda": [0, 10],
            "random_state": [19920722, 19920722],
            "n_jobs": [-1, -1],
            # "silent": "warn",
            # "importance_type": "split",
        },
    
    ("cat", "regressor"): {
            # "nan_mode": ["Min"],
            "eval_metric": ["RMSE"],
            # "iterations": [50,200],
            # "sampling_frequency": "PerTree",
            # "leaf_estimation_method": "Newton",
            # "grow_policy": "SymmetricTree",
            # "penalties_coefficient": 1,
            # "boosting_type": "Plain",
            # "model_shrink_mode": "Constant",
            # "feature_border_type": "GreedyLogSum",
            # "bayesian_matrix_reg": 0.10000000149011612,
            # "force_unit_auto_pair_weights": False,
            # "l2_leaf_reg": 3,
            # "random_strength": 1,
            # "rsm": 1,
            # "boost_from_average": False,
            # "model_size_reg": 0.5,
            # "pool_metainfo_options": {"tags": {}},
            # "subsample": 1,
            # "use_best_model": False,
            "random_seed": [19920722, 19920722],
            "depth": [4, 10],
            # "posterior_sampling": False,
            # "border_count": 254,
            # "classes_count": 0,
            # "auto_class_weights": "None",
            # "sparse_features_conflict_fraction": 0,
            # "leaf_estimation_backtracking": "AnyImprovement",
            # "best_model_min_trees": 1,
            # "model_shrink_rate": 0,
            # "min_data_in_leaf": 1,
            "loss_function": ["RMSE"],
            "learning_rate": [0.001, 0.3],
            # "score_function": "Cosine",
            # "task_type": "CPU",
            # "leaf_estimation_iterations": 10,
            # "bootstrap_type": "MVS",
            # "max_leaves": 64,
            # "scale_pos_weight": None,
            # "class_weights": None,
            # "eta": None,
            # "n_estimators": None,
            'verbose': [False, False],
    },
    
    ("rf", "regressor"): {        
            "n_estimators": [50, 500],
            "criterion": ["squared_error"],
            # "max_depth": None,
            "min_samples_split": [2, 20],
            "min_samples_leaf": [1, 20],
            # "min_weight_fraction_leaf": 0.0,
            # "max_features": "sqrt",
            # "max_leaf_nodes": None,
            # "min_impurity_decrease": 0.0,
            # "bootstrap": True,
            # "oob_score": False,
            "n_jobs": [-1, -1],
            "random_state": [19920722, 19920722],
            # "verbose": 0,
            # "warm_start": False,
            # "class_weight": None,
            # "ccp_alpha": 0.0,
            # "max_samples": None,
        },
    
    ("lm", "regressor"):{
            # "fit_intercept": [True],
            # "normalize": False,
            # "copy_X": True,
            "n_jobs": [-1, -1],
            # "positive": False,
        }
}
